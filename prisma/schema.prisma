// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ... Enums (Prisma handles mapping, keeping as is) ...

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  phone         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  resetToken    String?   @unique
  resetTokenExpiry DateTime?
  role          String    @default("USER") // SQLite doesn't support enums well, Prisma emulates or we use String. Let's start with String to be safe or keep Enum if Prisma handles it in client. Prisma SQLite supports Enums (mapped to string). Keeping Enums in Schema for Type safety in Client.
  status        String    @default("ACTIVE") // Using String for SQLite compatibility usually safer, but let's try keeping Enum first. Actually, for SQLite migration usually it's better to verify. Prisma docs say "SQLite: Enums are supported". Okay.

  // Tenant Profile Fields
  nextOfKinName  String?
  nextOfKinPhone String?
  employerName   String?
  jobTitle       String?
  isEmployed     Boolean   @default(false)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  tickets       Ticket[]
  payments      Payment[]
  activityLogs  ActivityLog[]
  leases        Lease[]
  documents     Document[]
  rentModifications RentModificationLog[] @relation("AdminRentModifications")
  ticketComments TicketComment[]
}

model Property {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Float
  location    String
  status      String   @default("AVAILABLE") // Enums with SQLite sometimes tricky, using String is robust.
  type        String
  images      String   @default("[]") // SQLite: Store as JSON String
  features    String?  @default("[]")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  leases      Lease[]
  documents   Document[]
}

model Material {
  id          String   @id @default(cuid())
  name        String
  description String
  category    String
  price       Float?
  images      String   @default("[]") // SQLite: Store as JSON String
  inStock     Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Ticket {
  id             String       @id @default(cuid())
  subject        String
  description    String
  category       String
  status         String       @default("PENDING")
  approvalStatus String       @default("PENDING_MANAGER")
  requiresApproval Boolean    @default(true)
  priority       String       @default("MEDIUM")
  images         String       @default("[]") // SQLite: Store as JSON String
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  comments       TicketComment[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

model TicketComment {
  id        String   @id @default(cuid())
  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  content   String
  createdAt DateTime @default(now())
}

model Payment {
  id          String        @id @default(cuid())
  amount      Float
  reference   String        @unique
  status      String        @default("PENDING")
  approvalStatus String     @default("APPROVED")
  method      String
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  leaseId     String?
  lease       Lease?        @relation(fields: [leaseId], references: [id])
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model ContactSubmission {
  id        String   @id @default(cuid())
  name      String
  email     String
  phone     String?
  message   String
  status    String   @default("NEW") // Could be an enum, but sticking to provided requests
  createdAt DateTime @default(now())
}

// --- Digital Transparency System Models ---

model ActivityLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  action    String   // Keeping as string or could use ActionType enum if strict
  entity    String
  entityId  String?
  details   String?
  createdAt DateTime @default(now())
}

model Lease {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  startDate   DateTime
  endDate     DateTime?
  rentAmount  Float
  isActive    Boolean  @default(true)
  documents   Document[]
  rentHistory RentModificationLog[]
  payments    Payment[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model RentModificationLog {
  id             String   @id @default(cuid())
  leaseId        String
  lease          Lease    @relation(fields: [leaseId], references: [id])
  adminId        String
  admin          User     @relation("AdminRentModifications", fields: [adminId], references: [id])
  previousAmount Float
  newAmount      Float
  reason         String?
  createdAt      DateTime @default(now())
}

model Document {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id])
  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id])
  leaseId    String?
  lease      Lease?    @relation(fields: [leaseId], references: [id])
  type       String
  category   String?
  url        String
  name       String
  createdAt  DateTime  @default(now())
}
